<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

## cachify-wrapper

Wraps a function with a caching layer

**Parameters**

-   `fn` **[Function][1]** 
-   `cache` **[Object][2]** KVStorage interface [must provide set(key, value, expired) and get(key) methods]
-   `options` **[Object][2]?** 
    -   `options.expire` **([Number][3] \| [Object][2])?** key expire options
        -   `options.expire.ttl` **[Number][3]** cached data ttl (TimeToLive) [in milliseconds] (optional, default `1000`)
        -   `options.expire.deviation` **[Number][3]** `ttl` deviation (prevents simultaneous keys deletions) [in milliseconds] (optional, default `options.expire.ttl/100`)
    -   `options.lock` **[Number][3]** lock timeout (prevents simultaneous concurrent invoke of `fn` at initial period) [in milliseconds] (optional, default `1000`)
    -   `options.stale` **([Boolean][4] \| [Object][2])?** allow to use a stale data
        -   `options.stale.lock` **[Number][3]** lock timeout for updating stale data [in milliseconds] (optional, default `options.lock`)
    -   `options.timeout` **[Number][3]?** max cache response time (in milliseconds) before considering it as disabled, and invoking actual request to source
    -   `options.latency` **[Number][3]** expected source response time  [in milliseconds]. With `options.retries` affect on awaiting for duplicate requests for first request result (optional, default `options.lock.timeout`)
    -   `options.retries` **[Number][3]** number of passes before new actual request (optional, default `(options.lock.timeout/options.latency)+1`)
    -   `options.hasher` **[Function][1]** creates key for KV-storage by `fn` arguments (optional, default `JSON.stringify`)
    -   `options.debug` **[Boolean][4]?** debug logs
-   `thisArg` **any** context for `fn` and `options.hasher`

**Examples**

```javascript
const wrapper = require('cachify-wrapper');
const redis = require('redis');
class RedisCache {
 constructor() {
  this.client = redis.createClient();
 }
 set (key, value, expire) {
  return new Promise((resolve, reject) => this.client.set(key, JSON.stringify(value), (error, value) => error ? reject(error) :
    expire ? this.client.pexpire(key, expire, (error) => error ? reject(error) : resolve(value)) :
    resolve(value)));
 }
 get (key) {
  return new Promise((resolve, reject) => this.client.get(key, (error, value) => error ? reject(error) : resolve(JSON.parse(value))));
 }
}
const cache = new RedisCache();
const sourceFunc = (a) => new Promise((resolve) => setTimeout(() => resolve(a * 2), 250));
const options = {expire: {ttl: 500}, lock: {timeout: 100}, latency: 100, retries: 1};
const cached = wrapper(sourceFunc, cache, options);
cached(123).then((payload) => console.dir(payload, {colors: true, depth: null})); // Invoke new request
setTimeout(() => cached(123).then((payload) => console.dir(payload, {colors: true, depth: null})), 200); // Will get cached result
setTimeout(() => cached(123).then((payload) => console.dir(payload, {colors: true, depth: null})), 50); // Will invoke new actual request (because of low retries & latency options it can't wait for first invoke cache)
```

Returns **[Function][1]** wrapped function

[1]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function

[2]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object

[3]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number

[4]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean
